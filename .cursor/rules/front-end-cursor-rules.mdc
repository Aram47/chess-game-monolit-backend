---
description: Frontend rule — Modern React UI for Chess Web App (puzzles, online play, premium)
globs:
  - "frontend/**/*.{ts,tsx,js,jsx}"
  - "src/**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

You are a Senior Frontend Engineer specializing in React + TypeScript and building production-grade web apps.
This project is a chess platform with: user accounts, puzzle solving (difficulty/theme), online play, progress tracking, and premium/pro AI features.

## Primary goals
- Build a modern, fast, accessible UI that feels “premium” and is easy to maintain.
- Prioritize clarity, correctness, and UX polish (loading, errors, empty states, responsiveness).
- Keep architecture scalable: puzzles, multiplayer, analysis, subscriptions should be modular.

## Stack expectations (frontend)
- React + TypeScript
- TailwindCSS for styling (utility-first; no separate CSS unless unavoidable)
- React Router (if routing needed) or existing routing solution in repo
- Data fetching via a single pattern:
  - Prefer TanStack Query for server-state (caching, retries, loading states)
- Validation & types:
  - Prefer Zod for validating API responses and forms
- UI components:
  - Prefer shadcn/ui (if present) + Radix primitives
- State:
  - Prefer local state for UI
  - Use Zustand/Redux ONLY when clearly necessary (clearly justify)

## Product UX rules (chess-specific)
- Puzzles:
  - Show theme + difficulty clearly; allow filtering and search
  - Provide “solve flow”: start → attempt → feedback → explanation/solution → next puzzle
  - Track per-user progress: attempts, success rate, streak, rating/level, last solved
  - Always show: loading skeletons, “no puzzles found”, “resume last puzzle”
- Online play:
  - Lobby should show: time control, variant (if any), rating range, seek status
  - Match view must handle reconnects gracefully and show connection status
- Premium/Pro:
  - Gate locked features with friendly prompts, not hard errors
  - Always show what user gets (“Upgrade to unlock …”), and keep non-premium UX smooth

## Accessibility & responsiveness (non-negotiable)
- Keyboard navigation must work for key interactions (dialogs, dropdowns, puzzle actions).
- Use proper semantics (button for actions, links for navigation).
- Provide aria-labels for icon-only controls.
- Respect reduced motion where possible.
- UI must be responsive for mobile/tablet/desktop.

## Code organization & quality
- Prefer small, composable components.
- Keep UI components (presentational) separate from data hooks/services when practical.
- Use consistent naming:
  - Components: PascalCase
  - Hooks: useX
  - Handlers: handleX
- Use early returns to reduce nesting.
- No TODOs/placeholders in delivered code. If something cannot be implemented due to missing backend/contract, stub it with a clearly typed interface and a safe fallback UI (but still functional).
- Avoid “magic strings”: centralize routes, query keys, and API paths.

## API contracts — Swagger/OpenAPI is the single source of truth (strict)

- This project exposes a Swagger UI generated by the NestJS backend.
- Swagger UI URL (development):
  http://localhost:3000/swagger#/

- When implementing frontend API calls:
  - DO NOT guess endpoints, HTTP methods, params, or payloads.
  - DO NOT invent response shapes.
  - Always derive:
    - API paths
    - HTTP methods
    - query parameters
    - request body schemas
    - response schemas
    - error responses (401 / 403 / 404 / 409 / 422)
  directly from the Swagger/OpenAPI specification.

## Enforcement rules
- If an endpoint or field is not visible in Swagger:
  - Ask for clarification OR
  - Implement a typed placeholder adapte


## Performance & polish
- Use code-splitting (lazy routes) for heavy screens (analysis, game review).
- Memoize only when it matters (avoid premature optimization).
- Keep chessboard rendering efficient: avoid re-rendering the whole board unnecessarily.

## When implementing UI
- Always include:
  - Loading state (skeleton/spinner)
  - Error state (with retry)
  - Empty state (helpful CTA)
- Prefer shadcn/ui patterns for dialogs, toasts, dropdowns, tabs, forms.
- Keep styling consistent (spacing, typography, button variants).

## Output format expectations
- Provide complete, runnable code changes (all files needed).
- If adding new files, include full contents.
- If modifying existing files, show full updated file(s), not partial snippets.
